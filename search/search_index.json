{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"hydroglass","text":"<p>Lightweight Python package for harmonic and anharmonic lattice dynamics in amorphous solids.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -e .\n</code></pre> <p>Optional extras for docs:</p> <pre><code>pip install -e .[docs]\n</code></pre>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>API: Lanczos</li> <li>API: Phonons</li> </ul>"},{"location":"#minimal-example-lanczos","title":"Minimal example (Lanczos)","text":"<pre><code>import numpy as np\nfrom hydroglass.lanczos import lanczos_tridiagonal, tridiagonal_eigh, haydock_spectral_density\n\nrng = np.random.default_rng(7)\nA = rng.normal(size=(60, 60)); A = 0.5 * (A + A.T)\nv0 = rng.normal(size=60); v0 /= np.linalg.norm(v0)\n\nalpha, beta, _ = lanczos_tridiagonal(A, v0, num_steps=20)\neta = 0.02\ntheta = tridiagonal_eigh(alpha, beta)\nomega = np.linspace(theta.min() - 10*eta, theta.max() + 10*eta, 4001)\nrho = haydock_spectral_density(alpha, beta, omega, eta)\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation-editable","title":"Installation (editable)","text":"<p>```bash pip install -e \".[dev,docs]\"</p>"},{"location":"api/lanczos/","title":"Lanczos","text":"<p>This module implements symmetric Lanczos tridiagonalization and the Haydock continued fraction.</p> <ul> <li><code>lanczos_tridiagonal</code>: build the Krylov basis and tridiagonal coefficients <code>(alpha, beta)</code>.</li> <li><code>tridiagonal_eigh</code>: eigenvalues of the implied tridiagonal matrix.</li> <li><code>haydock_greens_function</code>: evaluate the continued-fraction Green\u2019s function.</li> <li><code>haydock_spectral_density</code>: <code>rho(omega) = -1/pi * Im G(omega + i * eta)</code>.</li> </ul> <p>Note</p> <p>The routines accept dense NumPy arrays or <code>scipy.sparse</code> matrices. Docstrings follow Google style.</p>"},{"location":"api/lanczos/#quick-start","title":"Quick start","text":"<pre><code>import numpy as np\nfrom hydroglass.lanczos import (\n    lanczos_tridiagonal,\n    tridiagonal_eigh,\n    haydock_greens_function,\n    haydock_spectral_density,\n)\n\nrng = np.random.default_rng(7)\nA = rng.normal(size=(60, 60)); A = 0.5 * (A + A.T)\nv0 = rng.normal(size=60); v0 /= np.linalg.norm(v0)\n\nalpha, beta, _ = lanczos_tridiagonal(A, v0, num_steps=20, reorthogonalization=\"partial\")\n\neta = 0.02\ntheta = tridiagonal_eigh(alpha, beta)\nomega = np.linspace(theta.min() - 10*eta, theta.max() + 10*eta, 4001)\n\nG = haydock_greens_function(alpha, beta, omega, eta)\nrho = haydock_spectral_density(alpha, beta, omega, eta)\n</code></pre>"},{"location":"api/lanczos/#api-reference","title":"API reference","text":""},{"location":"api/lanczos/#hydroglass.lanczos.lanczos_tridiagonal","title":"hydroglass.lanczos.lanczos_tridiagonal","text":"<pre><code>lanczos_tridiagonal(matrix_or_linear_operator, initial_vector, num_steps, reorthogonalization='partial', atol_reorth=1e-12)\n</code></pre> <p>Perform symmetric Lanczos and return tridiagonal coefficients and basis.</p> <p>The implementation assumes a real symmetric (or Hermitian with real data) operator.</p> <p>Parameters:</p> Name Type Description Default <code>matrix_or_linear_operator</code> <code>object</code> <p>Dense ndarray, scipy.sparse matrix, or any object that supports the matmul operator with a vector.</p> required <code>initial_vector</code> <code>NDArray[floating]</code> <p>Starting vector. It will be normalized internally.</p> required <code>num_steps</code> <code>int</code> <p>Number of Lanczos steps m, with m &gt;= 1.</p> required <code>reorthogonalization</code> <code>Literal['none', 'partial', 'full']</code> <p>Strategy for numerical stability: - \"none\": no explicit reorthogonalization. - \"partial\": one pass against existing basis if loss detected. - \"full\": always orthogonalize against the entire basis built so far.</p> <code>'partial'</code> <code>atol_reorth</code> <code>float</code> <p>Threshold to trigger partial reorthogonalization.</p> <code>1e-12</code> <p>Returns:</p> Type Description <code>tuple[NDArray[floating], NDArray[floating], NDArray[floating]]</code> <p>Tuple (alpha, beta, V) where: alpha: Diagonal entries of the tridiagonal matrix, shape (m,). beta:  Subdiagonal entries (nonnegative), shape (m - 1,). V:     Orthonormal Lanczos basis, shape (n, m).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shapes are inconsistent or num_steps &lt; 1.</p>"},{"location":"api/lanczos/#hydroglass.lanczos.tridiagonal_eigh","title":"hydroglass.lanczos.tridiagonal_eigh","text":"<pre><code>tridiagonal_eigh(alpha, beta)\n</code></pre> <p>Eigenvalues of the symmetric tridiagonal defined by (alpha, beta).</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NDArray[floating]</code> <p>Diagonal entries, shape (m,).</p> required <code>beta</code> <code>NDArray[floating]</code> <p>Subdiagonal entries, shape (m-1,).</p> required <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>Eigenvalues in ascending order, shape (m,).</p>"},{"location":"api/lanczos/#hydroglass.lanczos.haydock_greens_function","title":"hydroglass.lanczos.haydock_greens_function","text":"<pre><code>haydock_greens_function(alpha, beta, omega, eta, terminator=None, tail_coupling_beta=None)\n</code></pre> <p>Evaluate Haydock continued-fraction Green function G(omega + i * eta).</p> <p>If 'terminator' is provided, it is used as the complex tail G_tail(z) at the bottom of the finite continued fraction, improving accuracy for small M. The last level is then:     g_{M-1}(z) = 1 / (z - alpha[M-1] - beta_tail^2 * G_tail(z)), where beta_tail defaults to beta[-1] when available, or can be passed explicitly through 'tail_coupling_beta'.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NDArray[floating]</code> <p>Array of alpha coefficients with shape (M,).</p> required <code>beta</code> <code>NDArray[floating]</code> <p>Array of beta coefficients with shape (M - 1,).</p> required <code>omega</code> <code>NDArray[floating]</code> <p>Real frequency grid with shape (Nw,).</p> required <code>eta</code> <code>float</code> <p>Positive small imaginary part.</p> required <code>terminator</code> <code>Callable[[NDArray[complexfloating]], NDArray[complexfloating]] | None</code> <p>Optional callable tail G_tail(z). It must accept a complex array z with shape (Nw,) and return an array of the same shape.</p> <code>None</code> <code>tail_coupling_beta</code> <code>float | None</code> <p>Optional coupling used at the last level when a terminator is provided. If None and beta.size &gt; 0, defaults to float(beta[-1]). If both None and beta.size == 0, defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[complexfloating]</code> <p>Complex array G(z) with shape (Nw,).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On invalid inputs.</p>"},{"location":"api/lanczos/#hydroglass.lanczos.haydock_spectral_density","title":"hydroglass.lanczos.haydock_spectral_density","text":"<pre><code>haydock_spectral_density(alpha, beta, omega, eta, terminator=None, tail_coupling_beta=None)\n</code></pre> <p>Return rho(omega) = -1/pi * Im G(omega + i * eta) using Haydock CF.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>NDArray[floating]</code> <p>Array of alpha coefficients with shape (M,).</p> required <code>beta</code> <code>NDArray[floating]</code> <p>Array of beta coefficients with shape (M - 1,).</p> required <code>omega</code> <code>NDArray[floating]</code> <p>Real frequency grid with shape (Nw,).</p> required <code>eta</code> <code>float</code> <p>Positive small imaginary part.</p> required <code>terminator</code> <code>Callable[[NDArray[complexfloating]], NDArray[complexfloating]] | None</code> <p>Optional terminator callable passed to haydock_greens_function.</p> <code>None</code> <code>tail_coupling_beta</code> <code>float | None</code> <p>Optional coupling used at the last level with terminator.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>Real array rho(omega) with shape (Nw,).</p>"},{"location":"api/phonon/","title":"Phonons","text":"<p>High-level tools for vibrational spectra.</p> <ul> <li><code>Mesh1D</code>: one-dimensional frequency mesh.</li> <li><code>PhononModel</code>: container with frequencies, eigenvectors, positions, masses, and optional scattering weights.   Includes projections (L/T) and dynamic structure factor.</li> </ul>"},{"location":"api/phonon/#example","title":"Example","text":"<pre><code>import numpy as np\nfrom hydroglass.spectra.phonon import Mesh1D, PhononModel\n\nfrequencies = np.array([1.0, 2.0, 3.0])\neigenvectors = np.eye(3)\nomega_mesh = Mesh1D(points=np.linspace(0.0, 4.0, 4001))\n\nmodel = PhononModel(\n    frequencies=frequencies,\n    eigenvectors=eigenvectors,\n    masses=None,\n    q_vectors=None,\n    omega_mesh=omega_mesh,\n)\n\nq = np.array([1.0, 0.0, 0.0])\nomega, sqw = model.dynamic_structure_factor(\n    q_vectors=q[None, :],\n    temperature=0.0,\n    polarization=\"longitudinal\",\n    broadening={\"kind\": \"gaussian\", \"sigma\": 0.05},\n)\n</code></pre>"},{"location":"api/phonon/#api-reference","title":"API reference","text":""},{"location":"api/phonon/#hydroglass.spectra.phonon.Mesh1D","title":"hydroglass.spectra.phonon.Mesh1D  <code>dataclass</code>","text":"<pre><code>Mesh1D(points, spacing=None)\n</code></pre> <p>Simple one dimensional mesh descriptor.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>NDArray[floating]</code> <p>One dimensional array of grid points. Must be monotonic.</p> <code>spacing</code> <code>float | None</code> <p>Optional uniform spacing. If None, no assumption is made.</p>"},{"location":"api/phonon/#hydroglass.spectra.phonon.PhononModel","title":"hydroglass.spectra.phonon.PhononModel  <code>dataclass</code>","text":"<pre><code>PhononModel(frequencies, eigenvectors, masses=None, positions=None, scattering_weights=None, q_vectors=None, omega_mesh=None, eigenvectors_kind='raw_cartesian', eigenvalue_kind='omega')\n</code></pre> <p>Phonon-like object with eigenvalues and eigenvectors.</p> <p>This container stores harmonic modes and exposes methods to compute projections and the dynamic structure factor on a frequency grid.</p> Shape conventions <ul> <li>Let natoms be the number of atoms.</li> <li>Degrees of freedom ndof = 3 * natoms.</li> <li>eigenvectors has shape (ndof, nmodes) with columns being modes.</li> <li>frequencies has shape (nmodes,).</li> </ul> Mass convention <ul> <li>eigenvectors_kind = \"raw_cartesian\": physical displacements are   e_{a,alpha}(m) / sqrt(M_a) if masses are provided.</li> <li>eigenvectors_kind = \"mass_weighted\": eigenvectors are already   mass-weighted displacements; no additional 1/sqrt(M) factor.</li> </ul> Eigenvalue convention <ul> <li>eigenvalue_kind = \"omega\": provided frequencies are \u03c9 &gt;= 0.</li> <li>eigenvalue_kind = \"omega_squared\": provided eigenvalues are \u03c9^2 &gt;= 0,   and the model converts to \u03c9 by taking a safe square root.</li> </ul> Positions and phases <ul> <li>If positions is provided (shape (natoms, 3)), the DSF uses phase   factors exp(i q dot r_a) per atom. Optional real scattering_weights   of shape (natoms,) weight atomic contributions (for example,   coherent scattering lengths).</li> </ul> <p>Attributes:</p> Name Type Description <code>frequencies</code> <code>NDArray[floating]</code> <p>Mode frequencies \u03c9_m &gt;= 0 with shape (nmodes,).</p> <code>eigenvectors</code> <code>NDArray[floating]</code> <p>Eigenvector matrix with shape (ndof, nmodes).</p> <code>masses</code> <code>NDArray[floating] | None</code> <p>Optional mass vector with shape (natoms,).</p> <code>positions</code> <code>NDArray[floating] | None</code> <p>Optional Cartesian positions with shape (natoms, 3).</p> <code>scattering_weights</code> <code>NDArray[floating] | None</code> <p>Optional per-atom real weights with shape (natoms,).</p> <code>q_vectors</code> <code>NDArray[floating] | None</code> <p>Optional preset q-points with shape (nq, 3).</p> <code>omega_mesh</code> <code>Mesh1D | None</code> <p>Optional one dimensional frequency mesh.</p> <code>eigenvectors_kind</code> <code>Literal['raw_cartesian', 'mass_weighted']</code> <p>\"raw_cartesian\" or \"mass_weighted\".</p> <code>eigenvalue_kind</code> <code>Literal['omega', 'omega_squared']</code> <p>\"omega\" or \"omega_squared\".</p>"},{"location":"api/phonon/#hydroglass.spectra.phonon.PhononModel.longitudinal_projection","title":"longitudinal_projection","text":"<pre><code>longitudinal_projection(q_vector)\n</code></pre> <p>Phase-less longitudinal diagnostic: |sum_a d_{a,m}| projected onto q_hat, squared.</p> <p>This is a local polarization measure; it is not the DSF amplitude.</p>"},{"location":"api/phonon/#hydroglass.spectra.phonon.PhononModel.dynamic_structure_factor","title":"dynamic_structure_factor","text":"<pre><code>dynamic_structure_factor(q_vectors, temperature, polarization='longitudinal', broadening=None, chunk_n_modes=None)\n</code></pre> <p>Compute one-phonon S(q, omega) for one or many q vectors.</p> <p>This is a vectorized interface. If q_vectors has shape (3,), the return has shape (nomega,). If q_vectors has shape (nq, 3), the return has shape (nomega, nq).</p> Model <p>S(q, omega) = sum_m [(n_B + 1) / (2 * omega_m)] * W_m(q) * K(omega|omega_m)</p> Projections <p>longitudinal: W_m(q) = | q dot B_m(q) |^2 transverse:   W_m(q) = | B_m(q) - q_hat (q_hat dot B_m(q)) |^2</p> <p>Parameters:</p> Name Type Description Default <code>q_vectors</code> <code>NDArray[floating] | NDArray[float64]</code> <p>Array of shape (3,) or (nq, 3). All q must be finite and nonzero.</p> required <code>temperature</code> <code>float</code> <p>Absolute temperature (k_B = 1).</p> required <code>polarization</code> <code>Literal['longitudinal', 'transverse']</code> <p>'longitudinal' or 'transverse'.</p> <code>'longitudinal'</code> <code>broadening</code> <code>dict[str, float] | None</code> <p>Kernel specification dict, e.g. {                                             'kind': 'gaussian',                                             'sigma': ...                                         } or {'kind': 'lorentzian', 'gamma': ...}. If None, a default Gaussian width proportional to the spectral span is used.</p> <code>None</code> <code>chunk_n_modes</code> <code>int | None</code> <p>Optional number of modes per chunk to limit memory use.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[NDArray[floating], NDArray[floating]]</code> <p>Tuple (omega, sqw) where omega has shape (nomega,) and sqw has shape: - (nomega,) if q_vectors was shape (3,) - (nomega, nq) if q_vectors was shape (nq, 3)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On invalid shapes, missing omega mesh, or invalid kernel params.</p>"},{"location":"examples/lanczos_basics/","title":"Lanczos basics: tridiagonalization, Green's function, and spectral density","text":"In\u00a0[13]: Copied! <pre># Parameters (edit here)\nN = 20  # dimension of the test matrix\nM = 20  # number of Lanczos steps (depth)\nETA = 1e-2  # positive imaginary shift for the Green's function\nSEED = 7  # RNG seed for reproducibility\nUSE_SPARSE = False  # set True to use scipy.sparse if available\n\n# Optionally scale the matrix so its spectrum sits comfortably in a target radius\nAUTO_SCALE = False  # set True to rescale A to have spectral radius ~ TARGET_RADIUS\n\nTARGET_RADIUS = 2.5  # only used when AUTO_SCALE is True\n\n# Omega grid resolution; the range will be derived from the Ritz values of T\nNOMEGA = 8001  # more points for sharper peaks when ETA is small\n\n# Toggle saving the figure\nSAVE_FIG = False\nFIG_PATH = \"lanczos_spectral_density.pdf\"\n</pre> # Parameters (edit here) N = 20  # dimension of the test matrix M = 20  # number of Lanczos steps (depth) ETA = 1e-2  # positive imaginary shift for the Green's function SEED = 7  # RNG seed for reproducibility USE_SPARSE = False  # set True to use scipy.sparse if available  # Optionally scale the matrix so its spectrum sits comfortably in a target radius AUTO_SCALE = False  # set True to rescale A to have spectral radius ~ TARGET_RADIUS  TARGET_RADIUS = 2.5  # only used when AUTO_SCALE is True  # Omega grid resolution; the range will be derived from the Ritz values of T NOMEGA = 8001  # more points for sharper peaks when ETA is small  # Toggle saving the figure SAVE_FIG = False FIG_PATH = \"lanczos_spectral_density.pdf\" In\u00a0[14]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import eigvalsh\nfrom numpy import trapezoid  # modern replacement for np.trapz\n\nfrom hydroglass.lanczos import (\n    lanczos_tridiagonal,\n    tridiagonal_eigh,\n    haydock_greens_function,\n    haydock_spectral_density,\n)\n\ntry:\n    import scipy.sparse as sp\n\n    SCIPY_OK = True\nexcept Exception:\n    SCIPY_OK = False\n\nrng = np.random.default_rng(SEED)\n\n\ndef make_symmetric_matrix(n: int, seed: int) -&gt; np.ndarray:\n    rng_local = np.random.default_rng(seed)\n    A = rng_local.normal(size=(n, n))\n    A = 0.5 * (A + A.T)\n    return A\n\n\ndef maybe_sparse(A: np.ndarray, use_sparse: bool):\n    if use_sparse and SCIPY_OK:\n        return sp.csr_matrix(A)\n    return A\n\n\ndef normalize(x: np.ndarray) -&gt; np.ndarray:\n    nrm = float(np.linalg.norm(x))\n    if nrm == 0.0 or not np.isfinite(nrm):\n        raise ValueError(\"Cannot normalize a zero or nonfinite vector.\")\n    return x / nrm\n\n\ndef build_T(alpha: np.ndarray, beta: np.ndarray) -&gt; np.ndarray:\n    m = alpha.size\n    T = np.zeros((m, m), dtype=float)\n    np.fill_diagonal(T, alpha)\n    if m &gt; 1:\n        T[np.arange(m - 1), np.arange(1, m)] = beta\n        T[np.arange(1, m), np.arange(m - 1)] = beta\n    return T\n\n\ndef lorentzian_sum(\n    omega_grid: np.ndarray, centers: np.ndarray, weights: np.ndarray, eta: float\n) -&gt; np.ndarray:\n    og = omega_grid[:, None]\n    ck = centers[None, :]\n    wk = weights[None, :]\n    return (wk * (1.0 / np.pi) * eta / ((og - ck) ** 2 + eta**2)).sum(axis=1)\n</pre> import numpy as np import matplotlib.pyplot as plt from numpy.linalg import eigvalsh from numpy import trapezoid  # modern replacement for np.trapz  from hydroglass.lanczos import (     lanczos_tridiagonal,     tridiagonal_eigh,     haydock_greens_function,     haydock_spectral_density, )  try:     import scipy.sparse as sp      SCIPY_OK = True except Exception:     SCIPY_OK = False  rng = np.random.default_rng(SEED)   def make_symmetric_matrix(n: int, seed: int) -&gt; np.ndarray:     rng_local = np.random.default_rng(seed)     A = rng_local.normal(size=(n, n))     A = 0.5 * (A + A.T)     return A   def maybe_sparse(A: np.ndarray, use_sparse: bool):     if use_sparse and SCIPY_OK:         return sp.csr_matrix(A)     return A   def normalize(x: np.ndarray) -&gt; np.ndarray:     nrm = float(np.linalg.norm(x))     if nrm == 0.0 or not np.isfinite(nrm):         raise ValueError(\"Cannot normalize a zero or nonfinite vector.\")     return x / nrm   def build_T(alpha: np.ndarray, beta: np.ndarray) -&gt; np.ndarray:     m = alpha.size     T = np.zeros((m, m), dtype=float)     np.fill_diagonal(T, alpha)     if m &gt; 1:         T[np.arange(m - 1), np.arange(1, m)] = beta         T[np.arange(1, m), np.arange(m - 1)] = beta     return T   def lorentzian_sum(     omega_grid: np.ndarray, centers: np.ndarray, weights: np.ndarray, eta: float ) -&gt; np.ndarray:     og = omega_grid[:, None]     ck = centers[None, :]     wk = weights[None, :]     return (wk * (1.0 / np.pi) * eta / ((og - ck) ** 2 + eta**2)).sum(axis=1) In\u00a0[15]: Copied! <pre># Dense test operator\nA_dense = make_symmetric_matrix(N, seed=SEED)\n\nif AUTO_SCALE:\n    # Rescale A so that its spectral radius is ~ TARGET_RADIUS\n    evals_full = eigvalsh(A_dense)\n    radius = float(np.max(np.abs(evals_full)))\n    if radius &gt; 0.0:\n        scale = TARGET_RADIUS / radius\n        A_dense = A_dense * scale\n        print(f\"Rescaled A by factor {scale:.3g} so radius ~ {TARGET_RADIUS}\")\n\nA = maybe_sparse(A_dense, USE_SPARSE)\n\n# Starting vector v0\nv0 = normalize(rng.normal(size=N))\n\n# Lanczos tridiagonalization\nalpha, beta, V = lanczos_tridiagonal(\n    matrix_or_linear_operator=A,\n    initial_vector=v0,\n    num_steps=M,\n    reorthogonalization=\"partial\",\n    atol_reorth=1e-12,\n)\n\nprint(f\"alpha shape: {alpha.shape}, beta shape: {beta.shape}, V shape: {V.shape}\")\n</pre> # Dense test operator A_dense = make_symmetric_matrix(N, seed=SEED)  if AUTO_SCALE:     # Rescale A so that its spectral radius is ~ TARGET_RADIUS     evals_full = eigvalsh(A_dense)     radius = float(np.max(np.abs(evals_full)))     if radius &gt; 0.0:         scale = TARGET_RADIUS / radius         A_dense = A_dense * scale         print(f\"Rescaled A by factor {scale:.3g} so radius ~ {TARGET_RADIUS}\")  A = maybe_sparse(A_dense, USE_SPARSE)  # Starting vector v0 v0 = normalize(rng.normal(size=N))  # Lanczos tridiagonalization alpha, beta, V = lanczos_tridiagonal(     matrix_or_linear_operator=A,     initial_vector=v0,     num_steps=M,     reorthogonalization=\"partial\",     atol_reorth=1e-12, )  print(f\"alpha shape: {alpha.shape}, beta shape: {beta.shape}, V shape: {V.shape}\") <pre>alpha shape: (20,), beta shape: (19,), V shape: (20, 20)\n</pre> In\u00a0[16]: Copied! <pre>theta = tridiagonal_eigh(alpha, beta)\npad = 10.0 * ETA\nOMEGA_MIN = float(theta.min() - pad)\nOMEGA_MAX = float(theta.max() + pad)\nomega = np.linspace(OMEGA_MIN, OMEGA_MAX, int(NOMEGA))\nprint(f\"omega range: [{OMEGA_MIN:.3f}, {OMEGA_MAX:.3f}] with {omega.size} points\")\n</pre> theta = tridiagonal_eigh(alpha, beta) pad = 10.0 * ETA OMEGA_MIN = float(theta.min() - pad) OMEGA_MAX = float(theta.max() + pad) omega = np.linspace(OMEGA_MIN, OMEGA_MAX, int(NOMEGA)) print(f\"omega range: [{OMEGA_MIN:.3f}, {OMEGA_MAX:.3f}] with {omega.size} points\") <pre>omega range: [-5.966, 5.234] with 8001 points\n</pre> In\u00a0[17]: Copied! <pre># Continued fraction evaluation\nG = haydock_greens_function(alpha=alpha, beta=beta, omega=omega, eta=ETA)\nrho_cf = haydock_spectral_density(alpha=alpha, beta=beta, omega=omega, eta=ETA)\n\n# Tridiagonal reference (exact for the continued fraction)\nT = build_T(alpha, beta)\ntheta_T, U_T = np.linalg.eigh(T)\nw_T = U_T[0, :] ** 2\nrho_T = lorentzian_sum(omega, theta_T, w_T, ETA)\n\n# Full matrix reference (all eigenpairs)\nevals_full, Q_full = np.linalg.eigh(A_dense)  # single call to align eigenpairs\ncoeff = Q_full.T @ v0\nw_full = np.abs(coeff) ** 2\nrho_full = lorentzian_sum(omega, evals_full, w_full, ETA)\n\n# Diagnostics\nprint(\"N =\", A_dense.shape[0], \" M =\", alpha.size)\nprint(\"max |rho_cf - rho_T|   =\", float(np.max(np.abs(rho_cf - rho_T))))\nprint(\"max |rho_cf - rho_full| =\", float(np.max(np.abs(rho_cf - rho_full))))\nprint(\"Integral of rho_cf =\", float(trapezoid(rho_cf, omega)))\n</pre> # Continued fraction evaluation G = haydock_greens_function(alpha=alpha, beta=beta, omega=omega, eta=ETA) rho_cf = haydock_spectral_density(alpha=alpha, beta=beta, omega=omega, eta=ETA)  # Tridiagonal reference (exact for the continued fraction) T = build_T(alpha, beta) theta_T, U_T = np.linalg.eigh(T) w_T = U_T[0, :] ** 2 rho_T = lorentzian_sum(omega, theta_T, w_T, ETA)  # Full matrix reference (all eigenpairs) evals_full, Q_full = np.linalg.eigh(A_dense)  # single call to align eigenpairs coeff = Q_full.T @ v0 w_full = np.abs(coeff) ** 2 rho_full = lorentzian_sum(omega, evals_full, w_full, ETA)  # Diagnostics print(\"N =\", A_dense.shape[0], \" M =\", alpha.size) print(\"max |rho_cf - rho_T|   =\", float(np.max(np.abs(rho_cf - rho_T)))) print(\"max |rho_cf - rho_full| =\", float(np.max(np.abs(rho_cf - rho_full)))) print(\"Integral of rho_cf =\", float(trapezoid(rho_cf, omega))) <pre>N = 20  M = 20\nmax |rho_cf - rho_T|   = 1.6227019727921288e-12\nmax |rho_cf - rho_full| = 5.053735208093713e-13\nIntegral of rho_cf = 0.9841620710697894\n</pre> In\u00a0[19]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7.2, 6.4), constrained_layout=True)\n\nax1.plot(omega, rho_cf, label=\"Haydock (continued fraction)\", lw=1.8)\nax1.plot(omega, rho_T, label=\"Tridiagonal T spectral measure\", lw=1.2, ls=\"--\")\nax1.plot(omega, rho_full, label=\"Full matrix (all eigenpairs)\", lw=1.0, ls=\":\")\nax1.set_xlabel(\"omega\")\nax1.set_ylabel(\"rho(omega)\")\nax1.set_title(\"Spectral densities compared\")\nax1.legend()\n\nax2.plot(omega, np.real(G), label=\"Re G\", lw=1.5)\nax2.plot(omega, np.imag(G), label=\"Im G\", lw=1.5)\nax2.set_xlabel(\"omega\")\nax2.set_ylabel(\"G(omega + i eta)\")\nax2.set_title(\"Green's function (Haydock)\")\nax2.legend()\n\nif SAVE_FIG:\n    fig.savefig(FIG_PATH, dpi=200)\n</pre> fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7.2, 6.4), constrained_layout=True)  ax1.plot(omega, rho_cf, label=\"Haydock (continued fraction)\", lw=1.8) ax1.plot(omega, rho_T, label=\"Tridiagonal T spectral measure\", lw=1.2, ls=\"--\") ax1.plot(omega, rho_full, label=\"Full matrix (all eigenpairs)\", lw=1.0, ls=\":\") ax1.set_xlabel(\"omega\") ax1.set_ylabel(\"rho(omega)\") ax1.set_title(\"Spectral densities compared\") ax1.legend()  ax2.plot(omega, np.real(G), label=\"Re G\", lw=1.5) ax2.plot(omega, np.imag(G), label=\"Im G\", lw=1.5) ax2.set_xlabel(\"omega\") ax2.set_ylabel(\"G(omega + i eta)\") ax2.set_title(\"Green's function (Haydock)\") ax2.legend()  if SAVE_FIG:     fig.savefig(FIG_PATH, dpi=200)"},{"location":"examples/lanczos_basics/#lanczos-basics-tridiagonalization-greens-function-and-spectral-density","title":"Lanczos basics: tridiagonalization, Green's function, and spectral density\u00b6","text":"<p>This notebook demonstrates the core utilities in <code>hydroglass.lanczos</code>:</p> <ul> <li><code>lanczos_tridiagonal</code>: build a Krylov basis and a symmetric tridiagonal.</li> <li><code>haydock_greens_function</code>: evaluate the continued-fraction Green's function.</li> <li><code>haydock_spectral_density</code>: compute the spectral density from the imaginary part.</li> </ul> <p>We run on a small random symmetric test matrix so results can be compared to exact diagonalization. The same workflow applies to large or sparse operators.</p> <p>Key points:</p> <ul> <li>The Haydock spectral density (continued fraction) must match the spectral measure of the tridiagonal T built from <code>(alpha, beta)</code> to numerical precision.</li> <li>Agreement with the full matrix spectrum requires either <code>M \u2248 N</code> or a moderate broadening <code>ETA</code>.</li> </ul>"},{"location":"examples/lanczos_basics/#build-a-test-operator-optionally-rescale-and-run-lanczos","title":"Build a test operator, optionally rescale, and run Lanczos\u00b6","text":"<p>We create a random symmetric matrix <code>A_dense</code>, optionally rescale it to fit in a target spectral radius, choose a random normalized starting vector <code>v0</code>, and run Lanczos.</p>"},{"location":"examples/lanczos_basics/#choose-omega-grid-from-the-ritz-values-of-t","title":"Choose omega grid from the Ritz values of T\u00b6","text":"<p>We derive the frequency window from the eigenvalues of the tridiagonal <code>T</code>. This ensures the integral of the spectral density is close to one (assuming the window covers the spectrum and <code>v0</code> is normalized).</p>"},{"location":"examples/lanczos_basics/#greens-function-spectral-density-and-references","title":"Green's function, spectral density, and references\u00b6","text":"<ul> <li><code>rho_cf</code>: Haydock continued fraction result.</li> <li><code>rho_T</code>: exact spectral measure of the tridiagonal <code>T</code> (should match <code>rho_cf</code>).</li> <li><code>rho_full</code>: Lorentzian sum over all eigenpairs of the full matrix (will match closely only if <code>M \u2248 N</code> or broadening is large).</li> </ul>"},{"location":"examples/lanczos_basics/#plots","title":"Plots\u00b6","text":"<p>Top: spectral densities compared. Bottom: real and imaginary parts of the Green's function from the Haydock continued fraction.</p>"},{"location":"examples/vdsf_heatmap/","title":"vDSF heatmap $\\omega \\, S(|q|, \\omega)$ with spherical averaging","text":"In\u00a0[\u00a0]: Copied! <pre># Parameters (edit here)\nfrom pathlib import Path\n\n# --- Inputs ---\n# dynmat_path = Path(\"data/dynmat.npy\")  # (3N, 3N) mass-weighted matrix\npositions_path = Path(\"data/positions.npy\")  # optional, shape (N, 3) or None\nmasses_path = None  # optional, shape (N,)\nweights_path = None  # optional, shape (N,)\n\n# --- q shell and averaging ---\nqmax = 2.5  # maximum |q|\nnq = 60  # number of |q| samples\nndir = 48  # number of directions per |q|\nsphere_grid = \"fibonacci\"  # \"fibonacci\" or \"random\"\nseed = None  # used only if sphere_grid == \"random\"\n\n# --- physics / DSF ---\ntemperature = 300.0\npolarization = \"longitudinal\"  # \"longitudinal\" or \"transverse\"\nkernel_kind = \"gaussian\"  # \"gaussian\" or \"lorentzian\"\nsigma = 0.05  # used for Gaussian; set 0.0 to auto ~ 3 * d\u03c9\ngamma = 0.00  # used for Lorentzian; set 0.0 to auto ~ 3 * d\u03c9\n\n# --- plotting / outputs ---\nplot_vdsf = True  # if True, plot omega * S; if False, plot S\nnormalize_columns = False  # normalize each |q| column by its max\nomegamax = 120.0  # optional omega cap for plot and saved grid; set None to skip\nvmax = 500.0  # optional colorbar upper bound; set None for auto\n\npdf_out = Path(\"sqw_heatmap_notebook.pdf\")\nnpz_out = Path(\"sqw_grid_notebook.npz\")\n</pre> # Parameters (edit here) from pathlib import Path  # --- Inputs --- # dynmat_path = Path(\"data/dynmat.npy\")  # (3N, 3N) mass-weighted matrix positions_path = Path(\"data/positions.npy\")  # optional, shape (N, 3) or None masses_path = None  # optional, shape (N,) weights_path = None  # optional, shape (N,)  # --- q shell and averaging --- qmax = 2.5  # maximum |q| nq = 60  # number of |q| samples ndir = 48  # number of directions per |q| sphere_grid = \"fibonacci\"  # \"fibonacci\" or \"random\" seed = None  # used only if sphere_grid == \"random\"  # --- physics / DSF --- temperature = 300.0 polarization = \"longitudinal\"  # \"longitudinal\" or \"transverse\" kernel_kind = \"gaussian\"  # \"gaussian\" or \"lorentzian\" sigma = 0.05  # used for Gaussian; set 0.0 to auto ~ 3 * d\u03c9 gamma = 0.00  # used for Lorentzian; set 0.0 to auto ~ 3 * d\u03c9  # --- plotting / outputs --- plot_vdsf = True  # if True, plot omega * S; if False, plot S normalize_columns = False  # normalize each |q| column by its max omegamax = 120.0  # optional omega cap for plot and saved grid; set None to skip vmax = 500.0  # optional colorbar upper bound; set None for auto  pdf_out = Path(\"sqw_heatmap_notebook.pdf\") npz_out = Path(\"sqw_grid_notebook.npz\") In\u00a0[\u00a0]: Copied! <pre># Imports and helpers\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import Optional, Literal\n\nfrom hydroglass.spectra.phonon import Mesh1D, PhononModel\n\n\ndef load_array_any(path: Optional[Path]):\n    if path is None:\n        return None\n    p = path.expanduser().resolve()\n    if not p.exists():\n        raise FileNotFoundError(f\"File not found: {p}\")\n    if p.suffix == \".npy\":\n        return np.load(p).astype(float, copy=False)\n    if p.suffix == \".npz\":\n        with np.load(p) as z:\n            key = list(z.keys())[0]\n            return z[key].astype(float, copy=False)\n    if p.suffix == \".txt\":\n        return np.loadtxt(p).astype(float, copy=False)\n    raise ValueError(f\"Unsupported file extension: {p.suffix}\")\n\n\ndef build_omega_mesh(\n    frequencies: np.ndarray,\n    overshoot: float = 0.2,\n    points: int = 3001,\n    omegamax: Optional[float] = None,\n) -&gt; Mesh1D:\n    fmin = max(0.0, float(np.min(frequencies)))\n    fmax = float(np.max(frequencies))\n    span = max(fmax - fmin, 1.0)\n    lo = max(0.0, fmin - overshoot * span)\n    hi = fmax + overshoot * span\n    if omegamax is not None and np.isfinite(omegamax) and omegamax &gt; 0.0:\n        hi = min(hi, float(omegamax))\n    return Mesh1D(points=np.linspace(lo, hi, int(points)))\n\n\ndef fibonacci_sphere(n: int) -&gt; np.ndarray:\n    if n &lt;= 0:\n        raise ValueError(\"ndir must be positive.\")\n    ga = np.pi * (3.0 - np.sqrt(5.0))\n    k = np.arange(n, dtype=float)\n    z = 1.0 - 2.0 * (k + 0.5) / n\n    r = np.sqrt(np.maximum(0.0, 1.0 - z * z))\n    theta = ga * k\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    dirs = np.stack([x, y, z], axis=1)\n    norms = np.linalg.norm(dirs, axis=1, keepdims=True)\n    return (dirs / np.maximum(norms, 1e-15)).astype(float)\n\n\ndef random_sphere(n: int, seed: Optional[int]) -&gt; np.ndarray:\n    if n &lt;= 0:\n        raise ValueError(\"ndir must be positive.\")\n    rng = np.random.default_rng(seed)\n    xyz = rng.normal(size=(n, 3))\n    norms = np.linalg.norm(xyz, axis=1, keepdims=True)\n    return (xyz / np.maximum(norms, 1e-15)).astype(float)\n\n\ndef build_q_vectors_spherical_average(\n    q_abs: np.ndarray,\n    ndir: int,\n    scheme: Literal[\"fibonacci\", \"random\"],\n    seed: Optional[int],\n) -&gt; np.ndarray:\n    if scheme == \"fibonacci\":\n        dirs = fibonacci_sphere(ndir)\n    else:\n        dirs = random_sphere(ndir, seed=seed)\n    q_all = q_abs[:, None, None] * dirs[None, :, :]\n    return q_all.reshape(q_abs.size * ndir, 3).astype(float)\n</pre> # Imports and helpers import numpy as np import matplotlib.pyplot as plt from typing import Optional, Literal  from hydroglass.spectra.phonon import Mesh1D, PhononModel   def load_array_any(path: Optional[Path]):     if path is None:         return None     p = path.expanduser().resolve()     if not p.exists():         raise FileNotFoundError(f\"File not found: {p}\")     if p.suffix == \".npy\":         return np.load(p).astype(float, copy=False)     if p.suffix == \".npz\":         with np.load(p) as z:             key = list(z.keys())[0]             return z[key].astype(float, copy=False)     if p.suffix == \".txt\":         return np.loadtxt(p).astype(float, copy=False)     raise ValueError(f\"Unsupported file extension: {p.suffix}\")   def build_omega_mesh(     frequencies: np.ndarray,     overshoot: float = 0.2,     points: int = 3001,     omegamax: Optional[float] = None, ) -&gt; Mesh1D:     fmin = max(0.0, float(np.min(frequencies)))     fmax = float(np.max(frequencies))     span = max(fmax - fmin, 1.0)     lo = max(0.0, fmin - overshoot * span)     hi = fmax + overshoot * span     if omegamax is not None and np.isfinite(omegamax) and omegamax &gt; 0.0:         hi = min(hi, float(omegamax))     return Mesh1D(points=np.linspace(lo, hi, int(points)))   def fibonacci_sphere(n: int) -&gt; np.ndarray:     if n &lt;= 0:         raise ValueError(\"ndir must be positive.\")     ga = np.pi * (3.0 - np.sqrt(5.0))     k = np.arange(n, dtype=float)     z = 1.0 - 2.0 * (k + 0.5) / n     r = np.sqrt(np.maximum(0.0, 1.0 - z * z))     theta = ga * k     x = r * np.cos(theta)     y = r * np.sin(theta)     dirs = np.stack([x, y, z], axis=1)     norms = np.linalg.norm(dirs, axis=1, keepdims=True)     return (dirs / np.maximum(norms, 1e-15)).astype(float)   def random_sphere(n: int, seed: Optional[int]) -&gt; np.ndarray:     if n &lt;= 0:         raise ValueError(\"ndir must be positive.\")     rng = np.random.default_rng(seed)     xyz = rng.normal(size=(n, 3))     norms = np.linalg.norm(xyz, axis=1, keepdims=True)     return (xyz / np.maximum(norms, 1e-15)).astype(float)   def build_q_vectors_spherical_average(     q_abs: np.ndarray,     ndir: int,     scheme: Literal[\"fibonacci\", \"random\"],     seed: Optional[int], ) -&gt; np.ndarray:     if scheme == \"fibonacci\":         dirs = fibonacci_sphere(ndir)     else:         dirs = random_sphere(ndir, seed=seed)     q_all = q_abs[:, None, None] * dirs[None, :, :]     return q_all.reshape(q_abs.size * ndir, 3).astype(float) In\u00a0[\u00a0]: Copied! <pre># D = load_array_any(dynmat_path)\n# assert D.ndim == 2 and D.shape[0] == D.shape[1], \"dynmat must be square\"\n# ndof = D.shape[0]\n# assert ndof % 3 == 0, \"dynmat dimension must be multiple of 3\"\n# natoms = ndof // 3\n\npositions = load_array_any(positions_path) if positions_path is not None else None\nmasses = load_array_any(masses_path) if masses_path is not None else None\nweights = load_array_any(weights_path) if weights_path is not None else None\n\nnatoms = (\n    positions.shape[0]\n    if positions is not None\n    else (\n        masses.shape[0]\n        if masses is not None\n        else (weights.shape[0] if weights is not None else None)\n    )\n)\n\nif positions is not None:\n    assert positions.shape == (natoms, 3)\nif masses is not None:\n    assert masses.shape == (natoms,)\nif weights is not None:\n    assert weights.shape == (natoms,)\n\n# Dense diagonalization\n# w2, V = np.linalg.eigh(D)\n# w2 = np.clip(w2, a_min=0.0, a_max=None)\n# order = np.argsort(w2)\n# w2 = w2[order]\n# V = V[:, order]\n\nw2 = np.load(\"data/eigval.npy\")  # (3N,) omega^2\nV = np.load(\"data/eigvec.npy\")  # (3N, 3N) mass-weighted\nndof = w2.shape[0]\n\nomega_for_mesh = np.sqrt(np.clip(w2, 0.0, None))\nomega_mesh = build_omega_mesh(\n    omega_for_mesh, overshoot=0.2, points=3001, omegamax=omegamax\n)\ndomega = float(np.mean(np.diff(omega_mesh.points)))\n\nmodel = PhononModel(\n    frequencies=w2,\n    eigenvectors=V,\n    masses=masses,\n    positions=positions,\n    scattering_weights=weights,\n    q_vectors=None,\n    omega_mesh=omega_mesh,\n    eigenvectors_kind=\"mass_weighted\",\n    eigenvalue_kind=\"omega_squared\",\n)\nomega_mesh.points[:5], omega_mesh.points[-5:], domega\n</pre> # D = load_array_any(dynmat_path) # assert D.ndim == 2 and D.shape[0] == D.shape[1], \"dynmat must be square\" # ndof = D.shape[0] # assert ndof % 3 == 0, \"dynmat dimension must be multiple of 3\" # natoms = ndof // 3  positions = load_array_any(positions_path) if positions_path is not None else None masses = load_array_any(masses_path) if masses_path is not None else None weights = load_array_any(weights_path) if weights_path is not None else None  natoms = (     positions.shape[0]     if positions is not None     else (         masses.shape[0]         if masses is not None         else (weights.shape[0] if weights is not None else None)     ) )  if positions is not None:     assert positions.shape == (natoms, 3) if masses is not None:     assert masses.shape == (natoms,) if weights is not None:     assert weights.shape == (natoms,)  # Dense diagonalization # w2, V = np.linalg.eigh(D) # w2 = np.clip(w2, a_min=0.0, a_max=None) # order = np.argsort(w2) # w2 = w2[order] # V = V[:, order]  w2 = np.load(\"data/eigval.npy\")  # (3N,) omega^2 V = np.load(\"data/eigvec.npy\")  # (3N, 3N) mass-weighted ndof = w2.shape[0]  omega_for_mesh = np.sqrt(np.clip(w2, 0.0, None)) omega_mesh = build_omega_mesh(     omega_for_mesh, overshoot=0.2, points=3001, omegamax=omegamax ) domega = float(np.mean(np.diff(omega_mesh.points)))  model = PhononModel(     frequencies=w2,     eigenvectors=V,     masses=masses,     positions=positions,     scattering_weights=weights,     q_vectors=None,     omega_mesh=omega_mesh,     eigenvectors_kind=\"mass_weighted\",     eigenvalue_kind=\"omega_squared\", ) omega_mesh.points[:5], omega_mesh.points[-5:], domega In\u00a0[\u00a0]: Copied! <pre>q_abs = np.linspace(0.0, float(qmax), int(nq))\nq_vectors = build_q_vectors_spherical_average(q_abs, int(ndir), sphere_grid, seed)\nnq_total = q_vectors.shape[0]\nassert nq_total == int(nq) * int(ndir)\n\nif kernel_kind == \"lorentzian\":\n    gam = float(gamma) if gamma and gamma &gt; 0.0 else max(3.0 * domega, 1e-6)\n    broadening = {\"kind\": \"lorentzian\", \"gamma\": gam}\nelse:\n    sig = float(sigma) if sigma and sigma &gt; 0.0 else max(3.0 * domega, 1e-6)\n    broadening = {\"kind\": \"gaussian\", \"sigma\": sig}\n\nomega, sqw_many = model.dynamic_structure_factor(\n    q_vectors=q_vectors,\n    temperature=float(temperature),\n    polarization=str(polarization),\n    broadening=broadening,\n    chunk_n_modes=None,\n)\n\nif plot_vdsf:\n    sqw_many = omega[:, None] * sqw_many\n\nif omegamax is not None and np.isfinite(omegamax) and omegamax &gt; 0.0:\n    keep = omega &lt;= float(omegamax)\n    omega = omega[keep]\n    sqw_many = sqw_many[keep, :]\n\nsqw_grid = sqw_many.reshape(omega.size, int(nq), int(ndir)).mean(axis=2)\n\nif normalize_columns:\n    col_max = np.maximum(np.max(sqw_grid, axis=0), 1e-16)\n    sqw_grid = sqw_grid / col_max[None, :]\n\nomega.shape, sqw_grid.shape\n</pre> q_abs = np.linspace(0.0, float(qmax), int(nq)) q_vectors = build_q_vectors_spherical_average(q_abs, int(ndir), sphere_grid, seed) nq_total = q_vectors.shape[0] assert nq_total == int(nq) * int(ndir)  if kernel_kind == \"lorentzian\":     gam = float(gamma) if gamma and gamma &gt; 0.0 else max(3.0 * domega, 1e-6)     broadening = {\"kind\": \"lorentzian\", \"gamma\": gam} else:     sig = float(sigma) if sigma and sigma &gt; 0.0 else max(3.0 * domega, 1e-6)     broadening = {\"kind\": \"gaussian\", \"sigma\": sig}  omega, sqw_many = model.dynamic_structure_factor(     q_vectors=q_vectors,     temperature=float(temperature),     polarization=str(polarization),     broadening=broadening,     chunk_n_modes=None, )  if plot_vdsf:     sqw_many = omega[:, None] * sqw_many  if omegamax is not None and np.isfinite(omegamax) and omegamax &gt; 0.0:     keep = omega &lt;= float(omegamax)     omega = omega[keep]     sqw_many = sqw_many[keep, :]  sqw_grid = sqw_many.reshape(omega.size, int(nq), int(ndir)).mean(axis=2)  if normalize_columns:     col_max = np.maximum(np.max(sqw_grid, axis=0), 1e-16)     sqw_grid = sqw_grid / col_max[None, :]  omega.shape, sqw_grid.shape In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots(figsize=(7.6, 4.6), constrained_layout=True)\nextent = [q_abs.min(), q_abs.max(), float(omega.min()), float(omega.max())]\nim = ax.imshow(\n    sqw_grid,\n    origin=\"lower\",\n    aspect=\"auto\",\n    extent=extent,\n    interpolation=\"nearest\",\n    cmap=\"RdYlBu_r\",\n    vmin=0,\n    vmax=(float(vmax) if vmax is not None else None),\n)\nax.set_xlabel(\"$|q|$\")\nax.set_ylabel(\"$\\omega$\")\ntitle_style = \"$\\omega \\,S$\" if plot_vdsf else \"S\"\nax.set_title(f\"{title_style}$(|q|, \\omega)$  ({polarization}, T={temperature})\")\ncbar = fig.colorbar(im, ax=ax, pad=0.02)\ncbar.set_label(\"$\\omega S(q, \\omega)$\" if plot_vdsf else \"S(q, omega)\")\n</pre> fig, ax = plt.subplots(figsize=(7.6, 4.6), constrained_layout=True) extent = [q_abs.min(), q_abs.max(), float(omega.min()), float(omega.max())] im = ax.imshow(     sqw_grid,     origin=\"lower\",     aspect=\"auto\",     extent=extent,     interpolation=\"nearest\",     cmap=\"RdYlBu_r\",     vmin=0,     vmax=(float(vmax) if vmax is not None else None), ) ax.set_xlabel(\"$|q|$\") ax.set_ylabel(\"$\\omega$\") title_style = \"$\\omega \\,S$\" if plot_vdsf else \"S\" ax.set_title(f\"{title_style}$(|q|, \\omega)$  ({polarization}, T={temperature})\") cbar = fig.colorbar(im, ax=ax, pad=0.02) cbar.set_label(\"$\\omega S(q, \\omega)$\" if plot_vdsf else \"S(q, omega)\") In\u00a0[\u00a0]: Copied! <pre>npz_out.parent.mkdir(parents=True, exist_ok=True)\nnp.savez_compressed(npz_out, q_abs=q_abs, omega=omega, sqw_grid=sqw_grid)\npdf_out.parent.mkdir(parents=True, exist_ok=True)\nfig.savefig(pdf_out, dpi=300)\nprint(f\"Saved grid to {npz_out.resolve()}\")\nprint(f\"Saved figure to {pdf_out.resolve()}\")\n</pre> npz_out.parent.mkdir(parents=True, exist_ok=True) np.savez_compressed(npz_out, q_abs=q_abs, omega=omega, sqw_grid=sqw_grid) pdf_out.parent.mkdir(parents=True, exist_ok=True) fig.savefig(pdf_out, dpi=300) print(f\"Saved grid to {npz_out.resolve()}\") print(f\"Saved figure to {pdf_out.resolve()}\") In\u00a0[\u00a0]: Copied! <pre>j = int(0.25 * (nq - 1))  # pick a quarter of the |q| range\nfig2, ax2 = plt.subplots(figsize=(6.0, 3.5), constrained_layout=True)\nax2.plot(omega, sqw_grid[:, j], lw=1.5)\nax2.set_xlabel(\"omega\")\nax2.set_ylabel(\"omega*S\" if plot_vdsf else \"S\")\nax2.set_title(f\"Column at |q| = {q_abs[j]:.3f}\")\n</pre> j = int(0.25 * (nq - 1))  # pick a quarter of the |q| range fig2, ax2 = plt.subplots(figsize=(6.0, 3.5), constrained_layout=True) ax2.plot(omega, sqw_grid[:, j], lw=1.5) ax2.set_xlabel(\"omega\") ax2.set_ylabel(\"omega*S\" if plot_vdsf else \"S\") ax2.set_title(f\"Column at |q| = {q_abs[j]:.3f}\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/vdsf_heatmap/#vdsf-heatmap-omega-sq-omega-with-spherical-averaging","title":"vDSF heatmap $\\omega \\, S(|q|, \\omega)$ with spherical averaging\u00b6","text":"<p>This notebook computes and plots a 2D heatmap of the dynamic structure factor $S(|q|, \\omega)$ (or its velocity-weighted variant $\\omega\\,S$), averaged over directions on the sphere at fixed $|q|$.</p> <p>Workflow</p> <ol> <li>Load a mass-weighted dynamical matrix $D$ of shape $(3N, 3N)$.</li> <li>Diagonalize: eigenvalues $\\omega^2$, eigenvectors are mass-weighted displacements.</li> <li>Build <code>PhononModel</code> from your package and compute $S(q, \\omega)$ on a shell of $|q|$ values with spherical averaging.</li> <li>Plot a publication-ready heatmap and save an NPZ grid.</li> </ol> <p>Notes</p> <ul> <li>If positions are in Angstrom, provide $q$ in 1/Angstrom.</li> <li>This notebook assumes your eigenvectors should be treated as <code>eigenvectors_kind=\"mass_weighted\"</code> and eigenvalues as <code>eigenvalue_kind=\"omega_squared\"</code>.</li> <li>The vectorized <code>dynamic_structure_factor(q_vectors=...)</code> API is used throughout.</li> </ul>"},{"location":"examples/vdsf_heatmap/#load-and-diagonalize-the-mass-weighted-dynamical-matrix","title":"Load and diagonalize the mass-weighted dynamical matrix\u00b6","text":"<p>We interpret eigenvalues as $\\omega^2$ and eigenvectors as mass-weighted displacements. Tiny negative eigenvalues from numerical noise are clipped to zero.</p>"},{"location":"examples/vdsf_heatmap/#build-q-shell-and-directions-compute-sq-omega-in-vectorized-form","title":"Build $|q|$ shell and directions; compute $S(q, \\omega)$ in vectorized form\u00b6","text":"<p>We optionally plot $\\omega\\,S$ (vDSF). You can normalize each column for visibility.</p>"},{"location":"examples/vdsf_heatmap/#plot-heatmap-and-save-the-grid","title":"Plot heatmap and save the grid\u00b6","text":"<p>The color scale shows either $S(q, \\omega)$ or $\\omega\\,S(q, \\omega)$ if the toggle is enabled above.</p>"},{"location":"examples/vdsf_heatmap/#quick-column-check-inspect-a-single-q-cut","title":"Quick column check (inspect a single |q| cut)\u00b6","text":"<p>This helps validate peak positions and qualitative features before using the full heatmap.</p>"}]}